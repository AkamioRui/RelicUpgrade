<!DOCTYPE html>

<html>
    
<head>
    <script type="module" >
        import * as d3_raw from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
/** @type {import( "d3" )} */
let d3 = d3_raw;
//control panel logic

let pieceCode = '_';
let mainstatCode = '_';
let thresholdCode = '6';
let substatCode = [];


let getCode = ()=>`./relicUpgrade ${pieceCode} ${mainstatCode} ${thresholdCode} ${substatCode.join(' ')}`;   




let piece_mainstat = {
    HEAD   :['HP'],    
    HANDS  :['ATK'],    
    BODY   :[
      'HPP',
      'ATKP',
      'DEFP',
      'CD',
      'CR',
      'EHR',
      'HEAL'
    ],    
    BOOTS  :[
      'HPP',
      'ATKP',
      'DEFP',
      'SPD'
    ],    
    PLANAR :[
      'HPP',
      'ATKP',
      'DEFP',
      'DMG'
    ],    
    ROPE   :[
      'HPP',
      'ATKP',
      'DEFP',
      'BE',
      'ER'
    ],      
};
let str2code = {
HP     : 0,
ATK    : 1,
DEF    : 2,
HPP    : 3,
ATKP   : 4,
DEFP   : 5,
SPD    : 6,
CR     : 7,
CD     : 8,
EHR    : 9,
ERS    : 10,
BE     : 11,
DMG    : -1,
HEAL   : -2,
ER     : -3,

HEAD  :0,
HANDS :1,
BODY  :2,
BOOTS :3,
PLANAR:4,
ROPE  :5
};
let piece_code2Str = {
'0': 'HEAD'  ,
'1': 'HANDS' ,
'2': 'BODY'  ,
'3': 'BOOTS' ,
'4': 'PLANAR',
'5': 'ROPE'  
};
let stat_code2Str = {
'0'  :'HP'      ,
'1'  :'ATK'     ,
'2'  :'DEF'     ,
'3'  :'HPP'     ,
'4'  :'ATKP'    ,
'5'  :'DEFP'    ,
'6'  :'SPD'     ,
'7'  :'CR'      ,
'8'  :'CD'      ,
'9'  :'EHR'     ,
'10' :'ERS'     ,
'11' :'BE'      ,
'-1' :'DMG'     ,
'-2' :'HEAL'    ,
'-3' :'ER'      ,

};


let pieceOpt = d3.selectAll('#piece .tbOpt');
let mainstatOpt = d3.selectAll('#mainstat .tbOpt');
let thresholdOpt = d3.selectAll('#thresholdSlider');
let substatOpt = d3.selectAll('#substat .tbOpt');
let codeElement = d3.select('#code');
let descElement = d3.select('#relicDesc');

d3.select('#jsonLabel').on('input',function(){
    let value = d3.select(this).property('value');
    let json = JSON.parse(value);

    descElement.text(
        `piece : ${piece_code2Str[json.piece]}\n`
        + `mainstat : ${stat_code2Str[json.mainstat]}\n`
        + `threshold : ${json.threshold}\n`
        + `substat : ${json.substat.map(v=>stat_code2Str[v]).join(' ')}`

    );
     
  
  })

//   fetch('/browserUI/result/LABEL.json').then(
//     response=>{
//         if(response.ok) return response.json();
//         else return Promise.reject(new Error("no file"));
//     }
//   ). then (
//     json => {
//         descElement.text(
//             `piece : ${piece_code2Str[json.piece]}\n`
//             + `mainstat : ${stat_code2Str[json.mainstat]}\n`
//             + `threshold : ${json.threshold}\n`
//             + `substat : ${json.substat.map(v=>stat_code2Str[v]).join(' ')}`
//         )
//     }
//   )






pieceOpt.each(function(){//append onclick event
    let thisPiece = this.classList[1];
    let thisPieceCode = str2code[thisPiece];
    let thisSelection = d3.select(this);
    let thisMainstat = piece_mainstat[thisPiece];
    let thisMainstatStr = thisMainstat.map(v=>'.'+v).join(', ');

    thisSelection.on('click',function(){

        //piece wise 
        // if selected : node not selected
        // if not selected : node be selected
        if(thisSelection.classed('selected')){
            thisSelection.classed('selected',false);
            pieceCode = '_';
            
        } else {
            pieceCode = thisPieceCode;
            pieceOpt.classed('selected',false);
            thisSelection.classed('selected',true);

            //change mainstat option
            
        }

        
        //mainstat wise
        // after piece wise
        // if none selected: show nothing
        // if there is piece selected: show piece mainstat
        //none is selected
        mainstatOpt.classed('selected',false);
        mainstatCode = '_';
        mainstatOpt.style('display','none'); 
        if(typeof pieceCode === 'number'){
            d3.selectAll('#mainstat :is('+thisMainstatStr+')')
                .style('display','block')
                ;
        }

        //substat wise
        // since mainstat is not going to be clicked, then unban all sub
        substatOpt.classed('banned',false);
        substatCode = [];
        substatOpt.each(function(){
            if (
                d3.select(this).classed('selected') &&
                !d3.select(this).classed('banned') 
            )substatCode.push(str2code[this.classList[1]]);
        });
    
        //apply changes to code
        codeElement.text(getCode());
    });
});

mainstatOpt.each(function(){//append onclick event
    let thisMain = this.classList[1];//stat name
    let thisMainCode = str2code[thisMain];//stat code
    let thisSelection = d3.select(this);//selection containing this mainstat
    let subSelection = substatOpt.filter(function(){
        return d3.select(this).classed(thisMain);
    })

    thisSelection.on('click',function(){

        //mainstat wise + substat wise
        // if click on selected: unselect node, and unban subs == this
        // if click on not selected: un select all, select node, 
        if(thisSelection.classed('selected')){
            thisSelection.classed('selected',false);
            mainstatCode = '_';

            substatOpt.classed('banned',false);

        } else {//initially not selected
            
            mainstatOpt.classed('selected',false);
            thisSelection.classed('selected',true);
            mainstatCode = thisMainCode;

            substatOpt.classed('banned',false);
            subSelection.classed('banned',true);
            substatCode = [];
            substatOpt.each(function(){
                if (
                    d3.select(this).classed('selected') &&
                    !d3.select(this).classed('banned') 
                )substatCode.push(str2code[this.classList[1]]);
            });

            
        }
  
        //apply changes to code
        codeElement.text(getCode());

    });
});

substatOpt.each(function(){//append onclick event
    let thisSub = this.classList[1];//stat name
    let thisSubCode = str2code[thisSub];//stat code
    let thisSelection = d3.select(this);//selection containing this mainstat
    

    thisSelection.on('click',function(){

        //update substat
        if(thisSelection.classed('selected')){
            thisSelection.classed('selected',false);

            substatCode = [];
            substatOpt.each(function(){
                if (
                    d3.select(this).classed('selected') &&
                    !d3.select(this).classed('banned') 
                )substatCode.push(str2code[this.classList[1]]);
            });

        } else if(thisSelection.classed('banned')){
            //nothing

        } else {//initially not selected
            thisSelection.classed('selected',true);
            
            substatCode.push(thisSubCode);
        }
        
        codeElement.text(getCode());
    });

});



thresholdOpt.on('input',function(){
    d3.select('#thresholdMeter > div').text(this.value);
    
    //update global var
    thresholdCode = this.value;
    codeElement.text(getCode());
});




  
    </script>  
    <script type="module">
        
import * as d3Raw from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

/** @type {import ("d3")} */  
const d3 =d3Raw;

//@ts-check
/** 
 * @typedef {object} node
 * @property {number} depth 
 * @property {number} price 
 * @property {number} succesR - success rate
 * @property {string} detail
 * @property {string} accept
 */
/** 
 * @typedef {object} link
 * @property {number} src
 * @property {number} dst
 * @property {number} chance
 */





// drawGraphD3(jsondata,{width:20,height:20,padding:20});


// fetch("result/STATE.json").then(
//   response=>{
//     if(response.ok) return response.json();
//     else return Promise.reject(
//       new Error("generate the result file first using the code provided above")
//     );
//   }
// ).then(
//   theJson => drawGraphD3_STATE(theJson)
// )


d3.select('#jsonState').on('input',function(){
  let value = d3.select(this).property('value');
  let json = JSON.parse(value);
  drawGraphD3_STATE(json);  

})



//--------------code---------------------------------------------------------//

const all = d3.select('body').append('div');
  const backButton = all.append('button').text('back').attr('class','back');
  const msgBox = all.append('p').attr('class','msgBox')
    .style('display','inline')
    .style('padding','0 10px')
  ;
  const nextButton = all.append('button').text('next').attr('class','next');
  all.append('br');
  const svg = all.append('svg');
  const svg_g = svg.append('g');
/**
 * @template _LinkData,_NodeData
 * @typedef {object} TreeLink
 * @property {number} id
 * @property {number} parentId
 * @property {_LinkData} linkData
 * @property {_NodeData} nodeData
 */ 
/**
 * @template _LinkData
 * @typedef {object} OuterLink
 * @property {number} id
 * @property {number} parentId
 * @property {_LinkData} linkData
 */ 

/**  
 * @typedef {object} STATENODE
 * @property {string} detail
 * @property {number} price
 * @property {number} succesR
 * @property {number} accept
 * @property {number} inHeap
 * */ 
/**  
 * @typedef {object} STATELINK
 * @property {number} chance
 * */ 
/**
 * 
 * @param {{treeLinks:TreeLink<STATELINK,STATENODE>[],outerLinks:OuterLink<any>[],msg:string}[]} jsondata 
 * @param {{width:number,height:number,padding:number}} nodeSetting 
 */
function drawGraphD3_STATE(jsondata){

  //common element
  // const all = d3.select('body').append('div');
  // const backButton = all.append('button').text('back').attr('class','back');
  // const msgBox = all.append('p').attr('class','msgBox')
  //   .style('display','inline')
  //   .style('padding','0 10px')
  // ;
  // const nextButton = all.append('button').text('next').attr('class','next');
  // all.append('br');
  // const svg = all.append('svg');
  // const svg_g = svg.append('g');
  
  svg_g.selectAll("*").remove();

  //create some constant variable
  //#region 
  /** @type {{width:number,height:number,padding:number,fill:string[]}} */
  let nodeSetting;
  nodeSetting = {
    width : 370,
    height : 25,
    padding : 10,
    fill: ["white","yellow","lime"]
  }
  
  
  /** @type {d3.StratifyOperator<TreeLink<STATELINK,STATENODE>>} */
  const json2heirarchy = d3.stratify();
    json2heirarchy
    .id(d=>d.id)
    .parentId(d=>d.parentId)
  ;
  /** @type {d3.TreeLayout<TreeLink<STATELINK,STATENODE>>} */
  const treelayout = d3.tree()
    .nodeSize([nodeSetting.height+nodeSetting.padding*2,nodeSetting.width*3])
  ; 
  let currentGraph = 0;

  /** @type {(d3.HierarchyPointLink<TreeLink<STATELINK,STATENODE>>&{linkData:any})[]} */
  let treeLinks;
  /** @type {d3.HierarchyNode<TreeLink<STATELINK,STATENODE>>[]} */
  let treeNodes;
  function getGraphData(){
    let root = json2heirarchy(jsondata[currentGraph].treeLinks);
    treeLinks = treelayout(root).links();
    treeNodes = root.descendants();

    treeLinks.forEach((link)=>{
      link.linkData = link.target.data.linkData;
    })
    /** @type {d3.HierarchyNode<TreeLink<any, any>>[]} */
    let treeNodesMap = [];
    treeNodes.forEach((d)=>{
      treeNodesMap[d.id] = d;
    })

    let treeOuterLinks = jsondata[currentGraph].outerLinks.map(
      (v)=>{
        let a = {source:treeNodesMap[v.parentId],target:treeNodesMap[v.id]};
        a.linkData=v.linkData;
        return a;
      }
    )
    treeLinks.push(...treeOuterLinks);
    
    
  }
  getGraphData();
  

  
  //#endregion


  
  //resizeSVG
  function resizeSVG(){
    // let xArr = treeNodes.map(d=>d.x);
    // let minX = Math.min(...xArr);
    // let maxX = Math.max(...xArr);
    // let yArr = treeNodes.map(d=>d.y);
    let yArr = treeNodes.map(d=>d.x);//flipped image
    let xArr = treeNodes.map(d=>d.y);//flipped image
    let minX = Math.min(...xArr);
    let maxX = Math.max(...xArr);
    let minY = Math.min(...yArr);
    let maxY = Math.max(...yArr);

    svg_g.attr('transform','translate('
      +(minX*(-1) + nodeSetting.width/2)+
      ','
      +(minY*(-1) + nodeSetting.height/2)+
      ')')
    ;

    svg
    .attr('width',nodeSetting.width + maxX-minX+1 + 10)
    .attr('height',nodeSetting.height + maxY-minY+1)
  }
  resizeSVG();



  const linkDataProperty = Object.entries( jsondata[0].treeLinks[0].linkData).map(v=>v[0]);
  // const nodeDataProperty = Object.entries( jsondata[0].treeLinks[0].nodeData).map(v=>v[0]);
  const nodeDataProperty = ["detail","price","succesR","accept"];
  
  
  //drawLinks
  //#region 
  /** @type {d3.Link< any, d3.HierarchyPointLink<TreeLink<STATELINK,STATENODE>, d3.HierarchyNode<TreeLink<STATELINK,STATENODE> >} */
  const linkGenerator = d3.linkHorizontal();
    linkGenerator  
    .source(d=>d.source)
    .target(d=>d.target)
    .x(d=>d.y*.680)
    .y(d=>d.x)
  ;
  /**
   * @param { d3.Selection<SVGPathElement, d3.HierarchyPointLink<TreeLink<STATELINK,STATENODE>>, SVGGElement, any>} myselection 
   */
  function initLink(myselection){
    myselection.each(function (d){
      let sourceClass = "from_"+d.source.id;
      let targetClass = "to_"+d.target.id;
      d3.select(this)
        .classed(sourceClass,true)
        .classed(targetClass,true);
    });

    let path = myselection.append('path') 
      // .attr('d',linkGenerator)
      .attr('fill',"none")
      // .attr('stroke',color)
    ;
    let text = myselection.append('text')
      // .attr('transform',d=> 'translate('
      //   + ((d.source.x*3+d.target.x*2)/5) +','
      //   + ((d.source.y*3+d.target.y*2)/5) +')'
      // )
      .attr('dominant-baseline','middle')
      .attr('text-anchor','start')
    ;
    linkDataProperty.forEach((property,index)=>{
      text.append('tspan').attr('class',property)
      // .text(d=>d.linkData[property])
      .attr('y',(index - (linkDataProperty.length-1)/2)*0.9 +'em')
      .attr('x',0);
    });
    
  }
  /**
   * @param { d3.Selection<SVGPathElement, d3.HierarchyPointLink<TreeLink<STATELINK,STATENODE>>, SVGGElement, any>} myselection 
   * @param {string} color 
   */
  function updateLink(myselection,color){
    let path = myselection.select('path') 
      .attr('d',linkGenerator)
      .attr('transform',(d)=>
        'translate('
        + (Math.max(d.source.y,d.target.y)*(1-.680)
        -  Math.abs(d.source.y-d.target.y)*(1-.680)/2)
        +',0)'
      )
      .attr('stroke',color)
    ;
    let text = myselection.select('text')
      .attr('transform',function(d){
        
        if(d.target.data.nodeData.detail.indexOf('Good3')!=-1) {
          //Good3-%d:(%.6lf)
          let tgtIdx = d.target.data.nodeData.detail.match(/\d+/g)[1];
          //C%2d,%2d:%s-%s-%s
          let srcIdx = d.source.data.nodeData.detail.match(/\d+/)[0];
          

          
          if(srcIdx==tgtIdx) return 'translate('
          + (d.source.y+nodeSetting.width/2+5) +','
          + (d.source.x - 8) +')'
          else return 'translate('
          + (d.source.y+nodeSetting.width/2+5) +','
          + (d.source.x + 8) +')'
        }
      
        else if(d.source.data.nodeData.detail.indexOf('up')!=-1){
          return 'translate('
          + (d.source.y+d.target.y)/2 +','
          + (d.source.x+d.target.x)/2 +')'
        }
        
        else return 'translate('
        + (d.target.y-nodeSetting.width/2-70) +','
        + (d.target.x) +')'
      })
    ;

    
    linkDataProperty.forEach(property=>{
      text.select('tspan.'+property)
      .text(d=>d.linkData[property])
    });

    
    
  }
  

  let linkElements = svg_g
    .append('g').attr('class','links')
    .selectAll('linkElement')
    .data(treeLinks).enter()
    .append('g').attr('class','link') 
    .call(initLink)
    .call(updateLink,'black')
  ;
  
  ///*  */3 gone, 5 edited, 6 added
  

  //#endregion








  //draw node;
  //#region 
  /** @typedef {SVGGElement & {oldNodeData:any,modified:number}} SVGNodeElement */
  /**
   * @param { d3.Selection<SVGGElement, d3.HierarchyNode<TreeLink<STATELINK,STATENODE>>, SVGGElement, any>} selection 
   */
  function initNode(selection){
    // selection
      // .attr('transform', d => 'translate('+d.x+','+d.y+')')
      // .each(function (d){
      //   this.oldNodeData = d.data.nodeData;
      // })
    selection.each(function (d){
      let idClass = "id_"+d.id;
      d3.select(this)
        .classed(idClass,true)
    });
    selection.append('rect')
      .attr('x'       ,-nodeSetting.width/2)
      .attr('y'       ,-nodeSetting.height/2)
      .attr('width'   ,nodeSetting.width)
      .attr('height'  ,nodeSetting.height)
      // .attr('fill','white')
      // .attr('stroke',color)
      .attr('stroke-width',3)

    let text = selection.append('text')
      .attr('dominant-baseline','middle')
      .attr('stroke','black')
      .attr('stroke-width',0.3)
    ;
      text.append('tspan').attr('class','label')
      .attr('x'       ,-nodeSetting.width/2+5)
      .attr('text-anchor','start')

      text.append('tspan').attr('class','number')
      .attr('x'       ,nodeSetting.width/2-5)
      .attr('text-anchor','end')
      // .attr('text-anchor','middle')
    
    // nodeDataProperty.forEach((property,index)=>{
    //   text.append('tspan').attr('class',property)
    //   .text(d=>d.data.nodeData[property])
    //   .attr('y',(index - (nodeDataProperty.length-1)/2)*0.9 +'em')
    //   .attr('x',0);
    // });
  }
  /**
     * @param { d3.Selection<SVGNodeElement , d3.HierarchyNode<TreeLink<STATELINK,STATENODE>>, SVGGElement, any> } selection 
     * @param {string} colorModiefied 
     * @param {string} colorStable 
     */
  function updateNode(selection,colorModiefied,colorStable){
    selection
      .attr('transform', d => 'translate('+d.y+','+d.x+')')
      .each(function (d){
        this.modified = 0;
        let newNodeData = d.data.nodeData;
        if(this.oldNodeData !== undefined){
          for(let v of Object.entries(this.oldNodeData)){
            if( v[1] === newNodeData[v[0]]) continue;
            this.modified = 1;
            break;
          }
        }
        this.oldNodeData = newNodeData;
      })
    ;
    selection.select('rect')
      .attr('fill',(d)=>{
        //[unknown,inheap,whitelisted]
        if(d.data.nodeData.accept)return nodeSetting.fill[2];
        else if(d.data.nodeData.inHeap)return nodeSetting.fill[1];
        else return nodeSetting.fill[0];
      })
      .attr('stroke',function (){
        
        if(this.parentNode.modified)return colorModiefied;
        else return colorStable;
      })
    ;
    // /** @type {STATENODE} */
    let text = selection.select('text');
    text.select('tspan.label').text((d)=>'>'
      + d.data.nodeData.detail + ':  '
    );
    
    text.select('tspan.number').text((d)=>''
      +(d.data.nodeData.price).toFixed(0)+ '/'
      +(d.data.nodeData.succesR).toFixed(4) + '='
      +(d.data.nodeData.succesR!=0?
        (d.data.nodeData.price/d.data.nodeData.succesR).toFixed(2) : "NAN")
    );
    // text.text((d)=>'>'
    //   + d.data.nodeData.detail + ':  '
    //   +(d.data.nodeData.succesR).toFixed(4) + '/'
    //   +(d.data.nodeData.price).toFixed(0) + '='
    //   +(d.data.nodeData.price!=0?
    //     (d.data.nodeData.succesR/d.data.nodeData.price*1000000).toFixed(2) : "NAN")
    // );

    
  }

  //first time creating node G and its element
  //#region 
  let nodeElements = svg_g.append('g').attr('class','nodes')
    .selectAll('nodeElement')
    .data(treeNodes).enter()
    .append('g').attr('class','node')
    .call(initNode,'black')
    .call(updateNode,'black','black')
  ;
  //#endregion

  //protocol to responding to new data;  
  

  //#endregion


  //appending function to the button
  const jsonDataLength = jsondata.length;
  function nextGraph(increment){
    
    currentGraph += increment;
    currentGraph = Math.min(Math.max(currentGraph, 0), jsonDataLength-1);

    //update appearance
    nextButton.style('visibility',()=>{
      if(currentGraph == jsonDataLength-1) return 'hidden';
      else return 'visible';
    });
    backButton.style('visibility',()=>{
      if(currentGraph == 0) return 'hidden';
      else return 'visible';
    });
    msgBox.text(jsondata[currentGraph].msg);
    
    //update the actuall graph
    getGraphData();
    resizeSVG();
    
    
    linkElements = linkElements.data(treeLinks, function (d){
      return d.source.id+','+d.target.id;
    } ).join(//normal: black, enter:green
      enter =>{
        return enter
        .append('g').attr('class','link') 
        .call(initLink)
        .call(updateLink,'lime');
      },
      update => {
        return update
        .call(updateLink,'black');
      },
      exit => {
        return exit.remove();
      }
    );
    

    
    nodeElements = nodeElements.data(treeNodes,d=>d.id)
    .join(//normal:black, new:lime, updated:aqua
      enter => {
        return enter
        .append('g').attr('class','node')
        .call(initNode)
        .call(updateNode,'lime','lime')
      },
      update => {
        return update
        .call(updateNode,'aqua','black')
      },
      exit => {
        return exit.remove();
      }
    )
    
  }
  nextButton.on('click',()=>nextGraph(1))
    .style('visibility',()=>{
      if(jsonDataLength < 2) return 'hidden';
    });
  backButton.on('click',()=>nextGraph(-1))
    .style('visibility','hidden');
  msgBox.text(jsondata[currentGraph].msg);

}






    </script>  
    
     <style>
        #option{
            width: 1600px;
            padding: 30px 0;
            background-color: rgb(169, 169, 169);
            
            display: flex;
            justify-content: space-evenly;

        }

        #option > div{
            background-color: rgb(227, 227, 227);
            box-sizing: border-box;
            width: 20%;
            aspect-ratio: 9/16;
            padding: 10px;

            display: grid;
            grid: 1fr 9fr / 1fr;
            /* justify-items: center;
            align-items: center; */
            
            



        }
        .tbHead{
            /* border:1px solid black  ; */
            box-sizing: border-box;
            border-bottom:1px solid rgb(169, 169, 169);
            
            align-content: center;
            justify-items: center;

            font-size:3em;
        }
        .tbBody{
            box-sizing: border-box;
            padding:5px;
            background-color: rgb(227, 227, 227);
            
            display: grid;
            grid: repeat(auto,max-content) / max-content;
            align-items: center;
            justify-items: center;
            align-content: start;
            
        }
        .tbOpt{
            margin:5px;
            padding:5px 20px;
            background-color: white;

            font-size: 1.5em;
        }
        .tbOpt.selected{
            background-color: green;
        }
        .tbOpt.banned{
            background-color: rgb(169, 169, 169);
        }

        #thresholdMeter{
            width: 50%;
            aspect-ratio: 1/1;
            align-content: center;
            justify-items: center;
            font-size: 3rem;
        }

        #mainstat .tbOpt{
            display:none;
        }

        #result{
            font-size: 3em;

            display: grid;
            grid: repeat(2, max-content) / repeat(2,max-content);
            
            
            /* justify-content: start; */
            
        }
        #result div{
            padding: 0 50px;
        }
        

       #guide{
        font-size: 1.5em;
       }

       #jsonLabel, #jsonState{ 
        width: 1600px;
        height: 300px;
        font-size: 3em;
       }
        
     </style>
</head>
    
<body>
    <pre id="guide">
        instruction:
        1. set the setting to match the desired relic
        2. open cmd inside the 'relic' folder (or cd into that folder)
        3. open cmd (make sure the path is to relic/browserUI/), paste the code generated, and run it
        4. paste the content of LABEL.json and STATE.json into the designated textarea/textbox below
        

        Interpreting the graph:
        each node has a name (at the left side of the node) describing its current condition:
            a. root.                A relic that has just been created
            b. start n.             A relic that has the desired mainstat and has n initial substat (either 3 or 4)
            c. C n1,n2: s1,s2,s3.   A relic that has sub1, sub2, sub3. n1 refer to how many desired substat present.
            d. good n1-n2.          A relic with all 4 substat that has n2 desired substat present. n1 refer to whether it start with 3 or 4 substat.
            e.up n1-n2,n3.          A relic where the desired substat in total has been upgraded n3 times. n1 refer to whether it start with 3 or 4 substat, 
                                    n2 refer to how many desired substat present before any substat is upgraded. Since each layer corresponds to the same level, the level of the relic can be implicitly interpeted.
        each node has a color 
            b. other than green implies a relic with this condition should be discarded.                                     
            a. when a node is green, it means that relic with this condition should be upgraded. 
                Note that while its rare, a green node that doesnt have a green parent instead should be treated as white node.
        each node has 3 number in the syntax: cost/chacne=rate. 
            it describe the chance/cost/rate of the relic that is currently at the condition described by that node's name, and that it will follows the decision taken by the graph.
            a. cost.    Refer to the average relic exp that will be spend from the current condition until getting relic with the desired quality. It is assumed that 1 relic fragment = 195 exp. 
            b. chance.  Refer to the average probability of getting relic with the desired quality,
            c. rate.    cost/chance. 
        each link between node has a number that represent the probability that the parent node (left node) will become the child node (right node) when upgraded
            
        


    </pre>

    <div id="menu">
        <div id="option">
            <!-- <div id="piece"> </div>
            <div id="mainstat"> </div> -->
                
            <div id="piece">
                <div class="tbHead">
                    <div>PEICE</div>
                </div>
                <div class="tbBody">
                    <div class="tbOpt HEAD   "> HEAD   </div>
                    <div class="tbOpt HANDS  "> HANDS  </div>
                    <div class="tbOpt BODY   "> BODY   </div>
                    <div class="tbOpt BOOTS  "> BOOTS  </div>
                    <div class="tbOpt PLANAR "> PLANAR </div>
                    <div class="tbOpt ROPE   "> ROPE   </div>
                </div>                
            </div>

            <div id="mainstat">
                <div class="tbHead">
                    <div>MAINSTAT</div>
                </div>
                <div class="tbBody">
                    <div class="tbOpt HP   "> HP   </div>
                    <div class="tbOpt ATK  "> ATK  </div>
                    <div class="tbOpt DEF  "> DEF  </div>
                    <div class="tbOpt HPP  "> HP%  </div>
                    <div class="tbOpt ATKP "> ATK% </div>
                    <div class="tbOpt DEFP "> DEF% </div>
                    <div class="tbOpt SPD  "> SPD  </div>
                    <div class="tbOpt CR   "> CR   </div>
                    <div class="tbOpt CD   "> CD   </div>
                    <div class="tbOpt EHR  "> EHR  </div>
                    <div class="tbOpt ERS  "> ERS  </div>
                    <div class="tbOpt BE   "> BE   </div>
                    <div class="tbOpt DMG  "> DMG  </div>
                    <div class="tbOpt HEAL "> HEAL </div>
                    <div class="tbOpt ER   "> ER   </div>
                    
                </div>                
            </div>

            <div id="substat">
                <div class="tbHead">
                    <div>SUBSTAT</div>
                </div>
                <div class="tbBody">
                    <div class="tbOpt HP"  > HP   </div>
                    <div class="tbOpt ATK" > ATK  </div>
                    <div class="tbOpt DEF" > DEF  </div>
                    <div class="tbOpt HPP" > HP%  </div>
                    <div class="tbOpt ATKP"> ATK% </div>
                    <div class="tbOpt DEFP"> DEF% </div>
                    <div class="tbOpt SPD" > SPD  </div>
                    <div class="tbOpt CR"  > CR   </div>
                    <div class="tbOpt CD"  > CD   </div>
                    <div class="tbOpt EHR" > EHR  </div>
                    <div class="tbOpt ERS" > ERS  </div>
                    <div class="tbOpt BE"  > BE   </div>
                </div>                
            </div>
            

            <div id="threshold">
                <div class="tbHead">
                    <div>Threshold</div>
                </div>
                <div class="tbBody">
                    <div id="thresholdMeter">
                        <div>6</div> 
                    </div>
                    <div>
                        <input type="range" id="thresholdSlider" min="1" max="9" step="1">
                    </div>
                </div> 
                
            </div>
            
        </div>

        <div id="result">
            
            <div>Code: </div>
            <div id="code">_</div>
            
            <div>Currently Showing</div>
            <pre id="relicDesc">_</pre>
        </div>

        <textarea id="jsonLabel">copy and paste LABEL.json generated by running the code</textarea>
        <textarea id="jsonState">copy and paste STATE.json generated by running the code</textarea>
        
        

        
        
    </div>
     
    
    
</body>


</html>